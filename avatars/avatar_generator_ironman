import cv2 as cv
import mediapipe as mp
import os
import numpy as np
import random

# CONFIGURATION
INPUT_FOLDER = "./dataset/test_wlasl"
OUTPUT_FOLDER = "./dataset/custom"
ASSET_HEAD = "./assets/iron_man_head.png" # You can keep using this or get an Iron Man one
os.makedirs(OUTPUT_FOLDER, exist_ok=True)

class AvatarGenerator:
    def __init__(self):
        self.mp_holistic = mp.solutions.holistic
        self.img_head = None
        if os.path.exists(ASSET_HEAD):
            # Safe load with alpha check
            loaded = cv.imread(ASSET_HEAD, cv.IMREAD_UNCHANGED)
            if loaded is not None:
                if len(loaded.shape) == 3 and loaded.shape[2] == 3:
                    self.img_head = cv.cvtColor(loaded, cv.COLOR_BGR2BGRA)
                elif len(loaded.shape) == 3 and loaded.shape[2] == 4:
                    self.img_head = loaded
                else: self.img_head = None

    # ==========================================
    # ðŸŽ¨ ADVANCED RENDERING ENGINES
    # ==========================================
    
    def draw_glow_circle(self, img, center, radius, color, strength=3):
        """ Draws a circle with a neon glow effect using alpha blending """
        overlay = img.copy()
        for i in range(1, strength + 1):
            # Outer fading layers
            alpha = 0.3 / i
            r = int(radius + (i * radius * 0.3))
            cv.circle(overlay, center, r, color, -1)
            cv.addWeighted(overlay, alpha, img, 1 - alpha, 0, img)
        # Solid Core
        cv.circle(img, center, radius, (255, 255, 255), -1)

    def draw_armor_plate(self, canvas, p1, p2, color, thickness, bulge=1.0):
        """ Draws detailed armor segments (Trapezoid shapes to look 3D) """
        h, w, _ = canvas.shape
        x1, y1 = int(p1.x * w), int(p1.y * h)
        x2, y2 = int(p2.x * w), int(p2.y * h)
        
        if (x1 < 10 and y1 < 10) or (x2 < 10 and y2 < 10): return

        # Vector Math
        dx, dy = x2 - x1, y2 - y1
        dist = np.sqrt(dx*dx + dy*dy)
        if dist == 0: return
        nx, ny = -dy/dist, dx/dist # Normal vector
        
        # Geometry
        w_joint = thickness * 0.4
        w_mid = thickness * 0.5 * bulge
        
        # 4-Point Polygon (Trapezoid-ish)
        pts = np.array([
            [x1 + nx*w_joint, y1 + ny*w_joint], # Top Left
            [x1 + dx*0.5 + nx*w_mid, y1 + dy*0.5 + ny*w_mid], # Mid Left bulge
            [x2 + nx*w_joint, y2 + ny*w_joint], # Bot Left
            [x2 - nx*w_joint, y2 - ny*w_joint], # Bot Right
            [x1 + dx*0.5 - nx*w_mid, y1 + dy*0.5 - ny*w_mid], # Mid Right bulge
            [x1 - nx*w_joint, y1 - ny*w_joint]  # Top Right
        ], dtype=np.int32)

        # Draw Base Plate
        cv.fillConvexPoly(canvas, pts, color)
        
        # Draw "Highlight" line for metallic look (Lighter Color)
        highlight = tuple([min(c + 60, 255) for c in color])
        cv.polylines(canvas, [pts], True, (20, 20, 20), 2, cv.LINE_AA) # Dark Outline
        
        # Add a mechanical joint circle at P1
        cv.circle(canvas, (x1, y1), int(thickness*0.3), (50, 50, 50), -1)
        cv.circle(canvas, (x1, y1), int(thickness*0.15), (200, 200, 200), -1)

    def draw_hud(self, canvas, w, h):
        """ Draws JARVIS interface elements """
        color = (255, 200, 0) # Cyan/Blue
        thick = 2
        l = 40
        # Corners
        cv.line(canvas, (20, 20), (20+l, 20), color, thick)
        cv.line(canvas, (20, 20), (20, 20+l), color, thick)
        cv.line(canvas, (w-20, h-20), (w-20-l, h-20), color, thick)
        cv.line(canvas, (w-20, h-20), (w-20, h-20-l), color, thick)
        
        # Text
        cv.putText(canvas, "JARVIS: ACTIVE", (30, h-30), cv.FONT_HERSHEY_SIMPLEX, 0.6, color, 1)
        cv.putText(canvas, "MK-85 TARGETING", (w-200, 40), cv.FONT_HERSHEY_SIMPLEX, 0.6, color, 1)

    def overlay_head_smart(self, bg, overlay, nose, width_px):
        if overlay is None: return
        h_bg, w_bg = bg.shape[:2]
        h_ov, w_ov = overlay.shape[:2]
        
        scale = width_px / w_ov
        new_w = int(width_px)
        new_h = int(h_ov * scale)
        try: res = cv.resize(overlay, (new_w, new_h))
        except: return

        x = int(nose.x * w_bg - new_w // 2)
        y = int(nose.y * h_bg - new_h * 0.6) 
        
        y1, y2 = max(0, y), min(h_bg, y + new_h)
        x1, x2 = max(0, x), min(w_bg, x + new_w)
        y1o, y2o = max(0, -y), min(new_h, h_bg - y)
        x1o, x2o = max(0, -x), min(new_w, w_bg - x)

        if y1 >= y2 or x1 >= x2 or y1o >= y2o or x1o >= x2o: return

        crop_bg = bg[y1:y2, x1:x2]
        crop_ov = res[y1o:y2o, x1o:x2o]
        
        alpha = crop_ov[:, :, 3] / 255.0
        alpha_inv = 1.0 - alpha

        for c in range(3):
            crop_bg[:, :, c] = (alpha * crop_ov[:, :, c] + alpha_inv * crop_bg[:, :, c])

    def zoom_landmarks(self, landmark_list, scale_factor):
        if not landmark_list: return
        for lm in landmark_list.landmark:
            lm.x = 0.5 + (lm.x - 0.5) * scale_factor
            lm.y = 0.5 + (lm.y - 0.5) * scale_factor

    # ==========================================
    # ðŸŽ¥ MAIN PROCESS LOOP
    # ==========================================
    def process_video(self, input_path, output_path):
        cap = cv.VideoCapture(input_path)
        if not cap.isOpened(): return False

        w = int(cap.get(cv.CAP_PROP_FRAME_WIDTH))
        h = int(cap.get(cv.CAP_PROP_FRAME_HEIGHT))
        fps = int(cap.get(cv.CAP_PROP_FPS)) or 30
        
        # Static Background Grid
        bg_static = np.full((h, w, 3), (20, 20, 20), dtype=np.uint8)
        step = 50
        for x in range(0, w, step): cv.line(bg_static, (x,0), (x,h), (40,40,40), 1)
        for y in range(0, h, step): cv.line(bg_static, (0,y), (w,y), (40,40,40), 1)

        out = cv.VideoWriter(output_path, cv.VideoWriter_fourcc(*'mp4v'), fps, (w, h))

        # --- IRON MAN COLORS (BGR) ---
        C_RED   = (20, 20, 180)    # Deep Red
        C_GOLD  = (80, 210, 255)   # Gold
        C_BLUE  = (255, 200, 0)    # Reactor Glow

        ZOOM = 0.75

        with self.mp_holistic.Holistic(min_detection_confidence=0.5, min_tracking_confidence=0.5) as holistic:
            while cap.isOpened():
                ret, frame = cap.read()
                if not ret: break

                results = holistic.process(cv.cvtColor(frame, cv.COLOR_BGR2RGB))
                canvas = bg_static.copy() 

                self.zoom_landmarks(results.pose_landmarks, ZOOM)
                self.zoom_landmarks(results.left_hand_landmarks, ZOOM)
                self.zoom_landmarks(results.right_hand_landmarks, ZOOM)

                # 1. Draw HUD
                self.draw_hud(canvas, w, h)

                if results.pose_landmarks:
                    lm = results.pose_landmarks.landmark
                    
                    shoulder_width = abs(lm[11].x - lm[12].x) * w
                    base_th = shoulder_width * 0.35 

                    # --- LEGS (Gold Thighs, Red Boots) ---
                    self.draw_armor_plate(canvas, lm[23], lm[25], C_GOLD, base_th*1.2, bulge=1.3) 
                    self.draw_armor_plate(canvas, lm[24], lm[26], C_GOLD, base_th*1.2, bulge=1.3)
                    self.draw_armor_plate(canvas, lm[25], lm[27], C_RED,  base_th*1.4, bulge=1.4) 
                    self.draw_armor_plate(canvas, lm[26], lm[28], C_RED,  base_th*1.4, bulge=1.4)

                    # --- TORSO ---
                    s_l, s_r = (int(lm[11].x*w), int(lm[11].y*h)), (int(lm[12].x*w), int(lm[12].y*h))
                    h_l, h_r = (int(lm[23].x*w), int(lm[23].y*h)), (int(lm[24].x*w), int(lm[24].y*h))
                    
                    torso_pts = np.array([s_l, s_r, h_r, h_l])
                    cv.fillConvexPoly(canvas, torso_pts, C_RED)
                    # Gold Ribs
                    cv.line(canvas, s_l, h_r, C_GOLD, int(base_th*0.5))
                    cv.line(canvas, s_r, h_l, C_GOLD, int(base_th*0.5))
                    
                    # --- ARC REACTOR ---
                    cx = int((s_l[0] + s_r[0] + h_l[0] + h_r[0]) / 4)
                    cy = int((s_l[1] + s_r[1]) * 0.7 + (h_l[1] + h_r[1]) * 0.3)
                    self.draw_glow_circle(canvas, (cx, cy), int(shoulder_width*0.15), C_BLUE)

                    # --- ARMS ---
                    self.draw_armor_plate(canvas, lm[11], lm[13], C_GOLD, base_th, bulge=1.3) # Bicep
                    self.draw_armor_plate(canvas, lm[12], lm[14], C_GOLD, base_th, bulge=1.3)
                    self.draw_armor_plate(canvas, lm[13], lm[15], C_RED, base_th*0.9, bulge=1.1) # Gauntlet
                    self.draw_armor_plate(canvas, lm[14], lm[16], C_RED, base_th*0.9, bulge=1.1)

                    # --- HEAD ---
                    if self.img_head is not None:
                        self.overlay_head_smart(canvas, self.img_head, lm[0], shoulder_width*1.5)

                # --- HANDS (Repulsors) ---
                if results.left_hand_landmarks:
                    mp.solutions.drawing_utils.draw_landmarks(
                        canvas, results.left_hand_landmarks, mp.solutions.holistic.HAND_CONNECTIONS,
                        mp.solutions.drawing_utils.DrawingSpec(color=C_RED, thickness=2, circle_radius=1),
                        mp.solutions.drawing_utils.DrawingSpec(color=C_GOLD, thickness=2))
                    # Repulsor
                    wrist = results.left_hand_landmarks.landmark[0]
                    idx = results.left_hand_landmarks.landmark[5]
                    hx, hy = int((wrist.x+idx.x)/2*w), int((wrist.y+idx.y)/2*h)
                    self.draw_glow_circle(canvas, (hx, hy), 8, C_BLUE, strength=2)

                if results.right_hand_landmarks:
                    mp.solutions.drawing_utils.draw_landmarks(
                        canvas, results.right_hand_landmarks, mp.solutions.holistic.HAND_CONNECTIONS,
                        mp.solutions.drawing_utils.DrawingSpec(color=C_RED, thickness=2, circle_radius=1),
                        mp.solutions.drawing_utils.DrawingSpec(color=C_GOLD, thickness=2))
                    # Repulsor
                    wrist = results.right_hand_landmarks.landmark[0]
                    idx = results.right_hand_landmarks.landmark[5]
                    hx, hy = int((wrist.x+idx.x)/2*w), int((wrist.y+idx.y)/2*h)
                    self.draw_glow_circle(canvas, (hx, hy), 8, C_BLUE, strength=2)

                out.write(canvas)

        cap.release()
        out.release()
        return True

    def run_batch(self):
        files = [f for f in os.listdir(INPUT_FOLDER) if f.endswith(".mp4")]
        print(f"ðŸš€ JARVIS: Rendering {len(files)} Armor assets...")
        for i, f in enumerate(files):
            print(f"Processing [{i+1}/{len(files)}]: {f}...")
            self.process_video(os.path.join(INPUT_FOLDER, f), os.path.join(OUTPUT_FOLDER, f))
        print("âœ… Done.")

if __name__ == "__main__":
    gen = AvatarGenerator()
    gen.run_batch()